diff --git a/librtt/Rtt_MPlatform.h b/librtt/Rtt_MPlatform.h
index 397e4334..ae355051 100755
--- a/librtt/Rtt_MPlatform.h
+++ b/librtt/Rtt_MPlatform.h
@@ -175,7 +175,10 @@ class MPlatform
 		virtual int CanOpenURL( const char* url ) const = 0;
 		virtual FontMetricsMap GetFontMetrics( const PlatformFont& font ) const = 0;
 		virtual const MCrypto& GetCrypto() const = 0;
-
+// STEVE CHANGE
+		virtual void BeginMainThreadFunc() const {}
+		virtual void EndMainThreadFunc() const {}
+// /STEVE CHANGE
 		virtual void GetPreference( Category category, Rtt::String * value ) const = 0;
 		virtual Preference::ReadValueResult GetPreference(const char* categoryName, const char* keyName) const = 0;
 		virtual OperationResult SetPreferences( const char* categoryName, const PreferenceCollection& collection ) const = 0;
diff --git a/librtt/Rtt_Runtime.cpp b/librtt/Rtt_Runtime.cpp
index 704f3d57..31018c0e 100755
--- a/librtt/Rtt_Runtime.cpp
+++ b/librtt/Rtt_Runtime.cpp
@@ -1397,6 +1397,7 @@ Runtime::BeginRunLoop()
 
 	// PlatformTimer
 	fTimer->SetInterval( kInterval );
+	fTimer->SetInterval( 0x8000 | kFps ); // <- STEVE CHANGE
 
 	// Initial call to main.lua can cause runtime to be suspended,
 	// e.g. via PlatformModalInteraction
@@ -1510,6 +1511,8 @@ Runtime::CoronaCoreSuspend()
 void
 Runtime::Suspend(bool sendApplicationEvents /* = true */)
 {
+	TimerGuard guard = MakeTimerGuard(); // <- STEVE CHANGE
+
 	// Determine if the runtime is currently running.
 	// Note: -1 means not started. 0 means running. 1 means suspended.
 	bool wasRunning = (0 == fIsSuspended);
@@ -1665,6 +1668,8 @@ Runtime::CoronaResumeAll()
 void
 Runtime::Resume(bool sendApplicationEvents /* = true */)
 {
+	TimerGuard guard = MakeTimerGuard(); // <- STEVE CHANGE
+
 	CoronaResumeAll();
 	// reset for the next time
 	fSuspendOverrideProperties = kSuspendAll;
diff --git a/librtt/Rtt_Runtime.h b/librtt/Rtt_Runtime.h
index 467b3c50..c36445e0 100644
--- a/librtt/Rtt_Runtime.h
+++ b/librtt/Rtt_Runtime.h
@@ -239,6 +239,25 @@ class Runtime : public MCallback,
 		void RestartRenderer();
 		void RestartRenderer( DeviceOrientation::Type orientation );
 
+// STEVE CHANGE
+		struct TimerGuard {
+			TimerGuard(const MPlatform& platform)
+			:	fPlatform(platform)
+			{
+				fPlatform.BeginMainThreadFunc();
+			}
+
+			~TimerGuard()
+			{
+				fPlatform.EndMainThreadFunc();
+			}
+
+			const MPlatform& fPlatform;
+		};
+
+		TimerGuard MakeTimerGuard() const { return TimerGuard( fPlatform ); }
+// /STEVE CHANGE
+
 	public:
 		// Inits renderer and then begins timer
 		void BeginRunLoop();
diff --git a/platform/windows/Corona.Native.Library.Win32/Interop/RuntimeEnvironment.cpp b/platform/windows/Corona.Native.Library.Win32/Interop/RuntimeEnvironment.cpp
index 39aff2e4..195b9e23 100644
--- a/platform/windows/Corona.Native.Library.Win32/Interop/RuntimeEnvironment.cpp
+++ b/platform/windows/Corona.Native.Library.Win32/Interop/RuntimeEnvironment.cpp
@@ -325,6 +325,8 @@ RuntimeEnvironment::RuntimeEnvironment(const RuntimeEnvironment::CreationSetting
 	{
 		fLoadedEvent.GetHandlerManager().Add(settings.LoadedEventHandlerPointer);
 	}
+
+	InitializeSRWLock(&fLock); // <- STEVE CHANGE
 }
 
 RuntimeEnvironment::~RuntimeEnvironment()
@@ -1376,6 +1378,7 @@ OperationResult RuntimeEnvironment::RunUsing(const RuntimeEnvironment::CreationS
 	fRuntimeState = RuntimeState::kStarting;
 	fLastOrientation = fProjectSettings.GetDefaultOrientation();
 	auto result = fRuntimePointer->LoadApplication(updatedLaunchOptions, fLastOrientation);
+	auto guard = fRuntimePointer->MakeTimerGuard(); // <- STEVE CHANGE
 	if (Rtt::Runtime::kSuccess == result)
 	{
 		// Load was successful. Start running the Corona application.
diff --git a/platform/windows/Corona.Native.Library.Win32/Interop/RuntimeEnvironment.h b/platform/windows/Corona.Native.Library.Win32/Interop/RuntimeEnvironment.h
index 79859006..4b520f6d 100644
--- a/platform/windows/Corona.Native.Library.Win32/Interop/RuntimeEnvironment.h
+++ b/platform/windows/Corona.Native.Library.Win32/Interop/RuntimeEnvironment.h
@@ -113,6 +113,7 @@ class RuntimeEnvironment
 
 		#pragma endregion
 
+		SRWLOCK fLock; // <- STEVE CHANGE
 
 		#pragma region CreationSettings Structure
 		/// <summary>Provides settings to be passed into the static CreateUsing() function.</summary>
diff --git a/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinInputDeviceManager.cpp b/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinInputDeviceManager.cpp
index 038edc29..df9683ca 100644
--- a/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinInputDeviceManager.cpp
+++ b/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinInputDeviceManager.cpp
@@ -1118,6 +1118,8 @@ void WinInputDeviceManager::OnReceivedMouseEvent(
 		return;
 	}
 
+	auto guard = runtimePointer->MakeTimerGuard(); // <- STEVE CHANGE
+
 	// Determine which mouse buttons are primary and secondary.
 	// Typically, the left mouse button is the primary, unless it has been swapped in the Control Panel.
 	bool areMouseButtonsNotSwapped = ::GetSystemMetrics(SM_SWAPBUTTON) ? false : true;
diff --git a/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinPlatform.cpp b/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinPlatform.cpp
index 1b7c8e47..5d817e7f 100644
--- a/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinPlatform.cpp
+++ b/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinPlatform.cpp
@@ -569,7 +569,7 @@ namespace Rtt
 				windowHandle = windowPointer->GetWindowHandle();
 			}
 		}
-		return Rtt_NEW(&GetAllocator(), WinTimer(callback, windowHandle));
+		return Rtt_NEW(&GetAllocator(), WinTimer(callback, windowHandle, &fEnvironment.fLock)); // <- STEVE CHANGE
 	}
 
 	PlatformBitmap* WinPlatform::CreateBitmap(const char* path, bool convertToGrayscale) const
@@ -1178,6 +1178,18 @@ namespace Rtt
 
 	#endif
 
+// STEVE CHANGE
+	void WinPlatform::BeginMainThreadFunc() const
+	{
+		AcquireSRWLockExclusive(&fEnvironment.fLock);
+	}
+
+	void WinPlatform::EndMainThreadFunc() const
+	{
+		ReleaseSRWLockExclusive(&fEnvironment.fLock);
+	}
+// /STEVE CHANGE
+
 	const MCrypto& WinPlatform::GetCrypto() const
 	{
 		return fCrypto;
diff --git a/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinPlatform.h b/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinPlatform.h
index 7b23b2bc..3a47d9da 100755
--- a/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinPlatform.h
+++ b/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinPlatform.h
@@ -142,6 +142,11 @@ class WinPlatform : public MPlatform
 		virtual void SetCursorForRect(const char *cursorName, int x, int y, int width, int height) const;
 #endif
 
+// STEVE CHANGE
+		virtual void BeginMainThreadFunc() const;
+		virtual void EndMainThreadFunc() const;
+// /STEVE CHANGE
+
 		virtual void Suspend( ) const;
 		virtual void Resume( ) const;
 		virtual void GetSafeAreaInsetsPixels(Rtt_Real &top, Rtt_Real &left, Rtt_Real &bottom, Rtt_Real &right) const;
diff --git a/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinTimer.cpp b/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinTimer.cpp
index 3e6792a4..4d5a5479 100644
--- a/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinTimer.cpp
+++ b/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinTimer.cpp
@@ -10,7 +10,15 @@
 #include "stdafx.h"
 #include "Rtt_WinTimer.h"
 #include <windows.h>
+// STEVE CHANGE
+#include "Rtt_WinPlatform.h"
+#include "Core/Rtt_Time.h"
 
+#pragma comment(lib, "Winmm.lib")
+
+// Precise sleep: https://github.com/blat-blatnik/Snippets/blob/main/precise_sleep.c
+// see also: https://blog.bearcats.nl/perfect-sleep-function
+// /STEVE CHANGE
 
 namespace Rtt
 {
@@ -19,26 +27,60 @@ std::unordered_map<UINT_PTR, Rtt::WinTimer *> WinTimer::sTimerMap;
 UINT_PTR WinTimer::sMostRecentTimerID;
 
 #pragma region Constructors/Destructors
-WinTimer::WinTimer(MCallback& callback, HWND windowHandle)
-:	PlatformTimer(callback)
+WinTimer::WinTimer(MCallback& callback, HWND windowHandle, PSRWLOCK lock)
+:	PlatformTimer(callback),
+// STEVE CHANGE
+	fQpcPerSecond(0),
+	fFPSInterval(0),
+	fPeriodMin(0),
+	fLock(lock)
+// /STEVE CHANGE
 {
 	fWindowHandle = windowHandle;
 	fTimerPointer = NULL;
 	fIntervalInMilliseconds = 10;
 	fNextIntervalTimeInTicks = 0;
+// STEVE CHANGE
+	ClearHandles();
+
+	bool useLegacyAPI = false; // TODO: version check, etc.
+	if (!useLegacyAPI)
+	{
+		bool initedOK = Init_V2();
+		if (!initedOK)
+		{
+			CleanUpResources();
+		}
+	}
+// /STEVE CHANGE
 }
 
 WinTimer::~WinTimer()
 {
+// STEVE CHANGE
+	if (UsingV2API())
+	{
+		Stop_V2(kQuitting);
+		CleanUpResources();
+	}
+	else
+// /STEVE CHANGE
 	Stop();
 }
 
 #pragma endregion
 
-
 #pragma region Public Methods
 void WinTimer::Start()
 {
+// STEVE CHANGE
+	if (UsingV2API())
+	{
+		Start_V2();
+		
+		return;
+	}
+// /STEVE CHANGE
 	// Do not continue if the timer is already running.
 	if (IsRunning())
 	{
@@ -60,6 +102,14 @@ void WinTimer::Start()
 
 void WinTimer::Stop()
 {
+// STEVE CHANGE
+	if (UsingV2API())
+	{
+		Stop_V2(kStopped);
+		
+		return;
+	}
+// /STEVE CHANGE
 	// Do not continue if the timer has already been stopped.
 	if (IsRunning() == false)
 	{
@@ -77,6 +127,15 @@ void WinTimer::Stop()
 
 void WinTimer::SetInterval(U32 milliseconds)
 {
+// STEVE CHANGE
+	if (milliseconds & 0x8000)
+	{
+		Rtt_ASSERT(milliseconds > 0 && milliseconds <= 0xFFFF);
+
+		SetFPS(milliseconds & 0x7FFF);
+	}
+	else
+// /STEVE CHANGE
 	fIntervalInMilliseconds = milliseconds;
 }
 
@@ -87,6 +146,14 @@ bool WinTimer::IsRunning() const
 
 void WinTimer::Evaluate()
 {
+// STEVE CHANGE
+	if (UsingV2API())
+	{
+		Evaluate_V2();
+		
+		return;
+	}
+// /STEVE CHANGE
 	// Do not continue if the timer is not running.
 	if (IsRunning() == false)
 	{
@@ -143,4 +210,313 @@ S32 WinTimer::CompareTicks(S32 x, S32 y)
 
 #pragma endregion
 
+// STEVE CHANGE
+// see links up top
+void WinTimer::PreciseSleep(double seconds)
+{
+	LARGE_INTEGER qpc;
+	::QueryPerformanceCounter(&qpc);
+	INT64 targetQpc = (INT64)(qpc.QuadPart + seconds * fQpcPerSecond);
+
+	if (fHandles[kWaitableTimer]) // Try using a high resolution timer first.
+	{
+		const double TOLERANCE = 0.001'02;
+		INT64 maxTicks = (INT64)fPeriodMin * 9'500;
+		for (;;) // Break sleep up into parts that are lower than scheduler period.
+		{
+			double remainingSeconds = (targetQpc - qpc.QuadPart) / (double)fQpcPerSecond;
+			INT64 sleepTicks = (INT64)((remainingSeconds - TOLERANCE) * 10'000'000);
+			if (sleepTicks <= 0)
+				break;
+
+			LARGE_INTEGER due;
+			due.QuadPart = -(sleepTicks > maxTicks ? maxTicks : sleepTicks);
+			SetWaitableTimerEx(fHandles[kWaitableTimer], &due, 0, NULL, NULL, NULL, 0);
+			WaitForSingleObject(fHandles[kWaitableTimer], INFINITE);
+			QueryPerformanceCounter(&qpc);
+		}
+	}
+	else // Fallback to Sleep.
+	{
+		const double TOLERANCE = 0.000'02;
+		double sleepMs = (seconds - TOLERANCE) * 1000 - fPeriodMin; // Sleep for 1 scheduler period less than requested.
+		int sleepSlices = (int)(sleepMs / fPeriodMin);
+		if (sleepSlices > 0)
+			Sleep((DWORD)sleepSlices * fPeriodMin);
+		QueryPerformanceCounter(&qpc);
+	}
+
+	while (qpc.QuadPart < targetQpc) // Spin for any remaining time.
+	{
+		YieldProcessor();
+		QueryPerformanceCounter(&qpc);
+	}
+}
+
+void WinTimer::SetFPS(U32 fps)
+{
+	fFPSInterval = 1.0 / fps;
+
+	TIMECAPS caps;
+
+	timeGetDevCaps(&caps, sizeof(TIMECAPS));
+	timeBeginPeriod(caps.wPeriodMin);
+
+	fPeriodMin = (int)( caps.wPeriodMin );
+	
+	LARGE_INTEGER qpf;
+
+	QueryPerformanceFrequency(&qpf);
+
+	fQpcPerSecond = qpf.QuadPart;
+}
+
+void WinTimer::ClearHandles()
+{
+	for (int i = 0; i < kNumHandles; i++)
+	{
+		fHandles[i] = NULL;
+	}
+}
+
+void WinTimer::CleanUpResources()
+{
+	if (NULL != fHandles[kThread])
+	{
+		WaitForSingleObject(fHandles[kThread], INFINITE);
+	}
+
+	for (int i = 0; i < kNumHandles; i++)
+	{
+		CloseHandle(fHandles[i]);
+	}
+	
+	ClearHandles();
+	
+	if (0 != fPeriodMin)
+	{
+		timeEndPeriod(fPeriodMin);
+		
+		fPeriodMin = 0;
+	}
+}
+
+static DWORD WINAPI ThreadProc(LPVOID lpParam)
+{
+	WinTimer* timer = (WinTimer*)lpParam;
+
+	timer->ThreadBody();
+
+	// TODO: errors...
+	return 1;
+}
+
+bool WinTimer::Init_V2()
+{
+	fState = kStopped;
+	fEvaluateBeganTime = InvalidBeganTime();
+
+	InitializeConditionVariable(&fStartedOrStoppedCond);
+
+	if (false) // Windows8OrGreater()? (need to do other logic too...)
+	{
+		// fHandles[kWaitableTimer] = CreateWaitableTimerEx(NULL, NULL, CREATE_WAITABLE_TIMER_HIGH_RESOLUTION, TIMER_ALL_ACCESS);
+		// ^^^ TODO!!! (constant not found??)
+	}
+
+	fHandles[kThread] = CreateThread(NULL, 0, ThreadProc, this, 0, NULL);
+
+	if (NULL != fHandles[kThread])
+	{
+		SetThreadPriority(fHandles[kThread], THREAD_PRIORITY_HIGHEST);
+	}
+	else
+	{
+		// TODO: error...
+	
+		return false;
+	}
+
+	return true;
+}
+
+void WinTimer::Start_V2()
+{
+	if (LockFromExpectedStateTo(kStopped, kRunning))
+	{
+		InterlockedExchange(&fState, kRunning);
+		WakeConditionVariable(&fStartedOrStoppedCond);
+	}
+// TODO: resume period?
+}
+
+void WinTimer::Stop_V2(LONG stopState)
+{
+	bool normalStop = LockFromExpectedStateTo(kRunning, kStopped);
+	if (normalStop || (kQuitting == stopState && LockFromExpectedStateTo(kStopped, kQuitting)))
+	{
+		if (normalStop)
+		{
+			fEvaluateBeganTime = InvalidBeganTime();
+		}
+
+		InterlockedExchange(&fState, stopState); // unlock or set quit state
+		WakeConditionVariable(&fStartedOrStoppedCond);
+	}
+// TODO: restore period?
+}
+
+void WinTimer::Evaluate_V2()
+{
+	// Do the timer proc. Assuming Start() and Stop() only arise from
+	// specific WM_* messages, and since the caller first does an "is
+	// running?" check, the enclosing WM_TIMER should ensure the proc
+	// completes without another Stop() along the way.
+	this->operator()();
+}
+
+bool WinTimer::LockFromExpectedStateTo(LONG from, LONG to)
+{
+	Rtt_ASSERT(from != to);
+
+	while (true)
+	{
+		LONG previous = InterlockedCompareExchange(&fState, kLocked, from);
+
+		Rtt_ASSERT(kQuitting != previous);
+
+		if (kLocked == previous)
+		{
+			YieldProcessor();
+			
+			continue;
+		}
+
+		bool didLock = (from == previous); // i.e. wasn't already "to"?
+		return didLock;
+	}
+}
+
+bool WinTimer::TryToLockFromExpectedState(LONG from, LONG* actual)
+{
+	LONG previous = InterlockedCompareExchange(&fState, kLocked, from);
+	bool wantsToQuit = kQuitting == previous;
+
+	if (NULL != actual)
+	{
+		*actual = previous;
+	}
+
+	return from == previous; // now locked?
+}
+
+bool WinTimer::WaitWhileStopped(PSRWLOCK lock)
+{
+	LONG actualState;
+
+	if (TryToLockFromExpectedState(kStopped, &actualState))
+	{
+		InterlockedExchange(&fState, kStopped); // unlock and wait
+		AcquireSRWLockExclusive(lock);
+
+		do {
+			SleepConditionVariableSRW(&fStartedOrStoppedCond, lock, INFINITE, 0);
+
+			actualState = InterlockedOr(&fState, 0);
+		} while (kRunning != actualState && kQuitting != actualState);
+
+		ReleaseSRWLockExclusive(lock);
+	}
+
+	return kQuitting != actualState;
+}
+
+void WinTimer::WaitForInterval(U64 beganWhen)
+{
+	U64 now = Rtt_GetAbsoluteTime();
+
+	Rtt_ASSERT(now >= beganWhen);
+
+	if (fPeriodMin)
+	{
+		double ns = (double)(now - beganWhen);
+// TODO: instead of divide, multiply by fps interval?
+		PreciseSleep(fFPSInterval - fmod(ns / 1'000'000, fFPSInterval));
+	}
+	else
+	{
+		DWORD leftover = fIntervalInMilliseconds - Rtt_AbsoluteToMilliseconds(now - beganWhen) % fIntervalInMilliseconds;
+		Sleep(leftover);
+	}
+}
+
+void WinTimer::ThreadBody()
+{
+	SRWLOCK waitWhileStoppedLock;
+
+	InitializeSRWLock(&waitWhileStoppedLock);
+
+	while (true)
+	{
+		// A "stop" either means something like minimizing the window,
+		// in which case the thread should go dormant, or quitting. In
+		// the former case, the situation should last a while, so we
+		// wait for a start event (such as a maximize) to wake us back
+		// up. If a stop happens later in the loop (and persists), it
+		// will effectively no-op and roll back around here anyway.
+		bool stillRunning = WaitWhileStopped(&waitWhileStoppedLock);
+		if (!stillRunning)
+		{
+			return;
+		}
+
+		// We do a lock here, mindful of the (unlikely) case another
+		// stop crept in, and fetch the otherwise potentially contended
+		// time, indicating when the last Evaluate() started. This will
+		// be bogus on the first frame, or if there was a stop along the
+		// way. If the time is valid at this point, we do the wait.
+		// It is possible a stop will occur while this is happening,
+		// but this is harmless aside from the (tiny) wasted delay.
+		if (TryToLockFromExpectedState(kRunning))
+		{
+			U64 evaluateBeganTime = fEvaluateBeganTime;
+
+			InterlockedExchange(&fState, kRunning); // unlock and wait
+
+			if (InvalidBeganTime() != evaluateBeganTime)
+			{
+				WaitForInterval(evaluateBeganTime);
+			}
+		}
+
+		// We do another lock here, given the also-unlikely prospect
+		// of a stop, either during the wait-for-interval or even the
+		// much narrower gap since the "started" event. We opt into
+		// the "stopped" events while still holding the lock, since
+		// a stop might also land before WM_TIMER gets processed.
+		// (There is also a guard condition for the pathological case
+		// that an intermediate stop triggers, followed by another
+		// start. Since the first such stop will signal the "stopped"
+		// event and kill the wait, we must interpret the situation
+		// as though that happened, even though the restart has us
+		// arrive running in the timer, cf. OnTimerElapsed_V2().)
+		AcquireSRWLockExclusive(fLock);
+
+		if (kRunning == fState)
+		{
+			fEvaluateBeganTime = Rtt_GetAbsoluteTime();
+
+			Evaluate_V2();
+
+			// ...and wait for it to get processed. If it does get picked
+			// up, i.e. a stop doesn't intervene, we can wait for Evaluate()
+			// to finish without further worries.
+
+		}
+
+		ReleaseSRWLockExclusive(fLock);
+	}
+}
+// /STEVE CHANGE
+
 }	// namespace Rtt
diff --git a/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinTimer.h b/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinTimer.h
index 94b58fb9..1c69f95c 100644
--- a/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinTimer.h
+++ b/platform/windows/Corona.Native.Library.Win32/Rtt/Rtt_WinTimer.h
@@ -26,7 +26,7 @@ class WinTimer : public PlatformTimer
 		/// <summary>Creates a new Win32 timer.</summary>
 		/// <param name="callback">The callback to be invoked every time the timer elapses.</param>
 		/// <param name="windowHandle">Handle to a window or control to attach the windows timer to. Can be null.</param>
-		WinTimer(MCallback& callback, HWND windowHandle);
+		WinTimer(MCallback& callback, HWND windowHandle, PSRWLOCK lock);
 
 		/// <summary>Destroys the timer and its resources. Stops the timer if currently running.</summary>
 		virtual ~WinTimer();
@@ -55,6 +55,10 @@ class WinTimer : public PlatformTimer
 		/// </summary>
 		void Evaluate();
 
+// STEVE CHANGE
+		void ThreadBody();
+// /STEVE CHANGE
+
 	private:
 		/// <summary>
 		///  <para>Called by Windows when the system timer has elapsed.</para>
@@ -86,6 +90,53 @@ class WinTimer : public PlatformTimer
 
 		static std::unordered_map<UINT_PTR, WinTimer*> sTimerMap; // timer callback might be called after Stop(), so use this as a guard
 		static UINT_PTR sMostRecentTimerID; // use an incrementing index as key, to be robust against the rare case that a new timer is reallocated into the same memory
+
+// STEVE CHANGE
+		void SetFPS(U32 fps);
+		void ClearHandles();
+		void CleanUpResources();
+
+		enum {
+			kRunning,
+			kStopped,
+			kLocked,
+			kQuitting // timer has quit and is being destroyed (final state)
+		};
+
+		bool UsingV2API() const { return NULL != fHandles[kThread]; }
+
+		bool Init_V2();
+
+		void Start_V2();
+		void Stop_V2(LONG stopState);
+		void Evaluate_V2();
+
+		enum {
+			kThread,
+			kWaitableTimer,
+
+			kNumHandles
+		};
+
+		bool LockFromExpectedStateTo(LONG from, LONG to);
+		bool TryToLockFromExpectedState(LONG from, LONG* actual = NULL);
+		bool WaitWhileStopped(PSRWLOCK lock);
+		void WaitForInterval(U64 beganWhen);
+
+		INT64 fQpcPerSecond;
+		double fFPSInterval;
+		int fPeriodMin;
+
+		void PreciseSleep(double seconds);
+
+		U64 InvalidBeganTime() const { return ~0ULL; }
+
+		PSRWLOCK fLock;
+		CONDITION_VARIABLE fStartedOrStoppedCond;
+		U64 fState; // n.b. mostly interpreted as a LONG
+		U64 fEvaluateBeganTime;
+		HANDLE fHandles[kNumHandles];
+// /STEVE CHANGE
 };
 
 }	// namespace Rtt
